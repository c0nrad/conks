// Generated by CoffeeScript 1.6.3
(function() {
  $(document).ready(function() {
    var app;
    app = window || {};
    if (app.constants == null) {
      app.constants = {};
    }
    app.constants = _.extend(app.constants, {
      roundStates: ["intro", "wave", "outro", "exit"],
      roundCountersPerLetter: 4,
      startRound: 0,
      npcColor: {
        Princess: "#FF5CCD",
        Thor: "#290014"
      },
      ledgeColor: "#964B00",
      textColor: "#000000",
      textFont: "18px Arial",
      smallTextFont: "14px Arial",
      arrowLineWidth: 3,
      groundColor: "#00FF00"
    });
    app.RoundModel = Backbone.Model.extend({
      defaults: function() {
        return {
          currentWaveNumber: -1,
          roundState: "intro",
          roundCounter: 0
        };
      },
      initialize: function() {
        if (this.get('isGameOver')) {
          this.set('roundState', 'gameOver');
          return;
        }
        if (this.get('introText') == null) {
          this.set('roundState', "wave");
        }
        this.set('introLength', _.reduce(this.get('introText'), function(acc, _arg) {
          var name, text;
          name = _arg[0], text = _arg[1];
          return acc + text.length;
        }, 0));
        return this.set('outroLength', _.reduce(this.get('outroText'), function(acc, _arg) {
          var name, text;
          name = _arg[0], text = _arg[1];
          return acc + text.length;
        }, 0));
      },
      nextWave: function() {
        var numberOfMonsters, numberOfMonstersPerWave, waveNumber, x, _i, _ref, _results;
        waveNumber = this.get('currentWaveNumber');
        numberOfMonstersPerWave = this.get('numberOfMonstersPerWave');
        numberOfMonsters = numberOfMonstersPerWave[waveNumber];
        _results = [];
        for (x = _i = 0, _ref = numberOfMonsters - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
          _results.push(app.monsters.spawnMonster(this.get('monsterColor')));
        }
        return _results;
      },
      update: function() {
        this.set('roundCounter', this.get('roundCounter') + 1);
        switch (this.get('roundState')) {
          case "intro":
            if (app.gameView.keyMap[13]) {
              this.set('roundState', 'wave');
            }
            if (this.get('roundCounter') > this.get('introLength') * app.constants.roundCountersPerLetter) {
              return this.set('roundState', 'wave');
            }
            break;
          case "wave":
            if (!app.monsters.allDead()) {
              return;
            } else {
              this.set('currentWaveNumber', this.get('currentWaveNumber') + 1);
            }
            if (this.get('currentWaveNumber') > this.get('numberOfMonstersPerWave').length) {
              this.set('roundState', 'outro');
              this.set('roundCounter', 0);
              return;
            }
            return this.nextWave();
          case "outro":
            if (app.gameView.keyMap[13]) {
              this.set('roundState', 'exit');
            }
            if (this.get('roundCounter') > this.get('outroLength') * app.constants.roundCountersPerLetter) {
              return this.set('roundState', "exit");
            }
            break;
          case "exit":
            if (app.playerModel.get('x') > app.constants.canvasX - app.constants.playerSizeX * 2) {
              app.playerModel.set('x', app.constants.playerSizeX * 2);
              return this.trigger("roundComplete");
            }
        }
      },
      height: function(x) {
        if (this.get('groundHeight') == null) {
          return 0;
        }
        return this.get('groundHeight')[x] || 0;
      }
    });
    app.RoundView = Backbone.View.extend({
      el: "#gameCanvas",
      initialize: function() {
        _.bindAll(this, "render");
        return this.model.view = this;
      },
      render: function() {
        var canvas, ctx;
        canvas = ($(this.el)[0]);
        ctx = canvas.getContext("2d");
        switch (this.model.get('roundState')) {
          case "intro":
            this.renderCini(ctx, 'introText', app.constants.npcColor[this.model.get('introNPC')]);
            break;
          case "outro":
            this.renderCini(ctx, 'outroText', app.constants.npcColor[this.model.get('outroNPC')]);
            break;
          case "exit":
            this.drawArrow(ctx, app.constants.canvasX - 300, app.constants.canvasY / 3);
            this.drawArrow(ctx, app.constants.canvasX - 300, 2 * app.constants.canvasY / 3);
            break;
          case "gameOver":
            this.renderGameOver();
        }
        this.drawGround(ctx);
        return this;
      },
      renderCini: function(ctx, textType, npcColor) {
        var displayText, name, roundCountersLeft, text, x, y, _i, _len, _ref, _ref1, _ref2, _ref3;
        roundCountersLeft = this.model.get('roundCounter');
        _ref = this.model.get(textType);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], name = _ref1[0], text = _ref1[1];
          if (roundCountersLeft === 0) {
            break;
          } else if (roundCountersLeft > text.length * app.constants.roundCountersPerLetter) {
            roundCountersLeft -= text.length * app.constants.roundCountersPerLetter;
            continue;
          } else {
            displayText = text.slice(0, +(roundCountersLeft / app.constants.roundCountersPerLetter) + 1 || 9e9);
            roundCountersLeft = 0;
            if (name === "Blocky") {
              _ref2 = [app.playerModel.get('x') - 30, app.playerModel.get('y') - 10], x = _ref2[0], y = _ref2[1];
            } else {
              _ref3 = [app.constants.canvasX - 400, 230], x = _ref3[0], y = _ref3[1];
            }
            ctx.fillStyle = app.constants.textColor;
            ctx.font = app.constants.textFont;
            ctx.fillText(displayText, x, y);
          }
        }
        this.renderLedge(npcColor);
        return this.renderSkipText();
      },
      drawGround: function(ctx) {
        var height, x, y, _i, _ref, _results;
        _results = [];
        for (x = _i = 0, _ref = app.constants.canvasXBlock - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
          height = this.model.height(x);
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (y = _j = 0; 0 <= height ? _j <= height : _j >= height; y = 0 <= height ? ++_j : --_j) {
              _results1.push(this.fillBlock(ctx, x, app.constants.canvasYBlock - y));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      },
      fillBlock: function(ctx, x, y) {
        var height, width, _ref;
        ctx.fillStyle = app.constants.groundColor;
        width = height = app.constants.playerSizeX - 2;
        _ref = [x * app.constants.playerSizeX - 1, y * app.constants.playerSizeY - 1], x = _ref[0], y = _ref[1];
        return ctx.fillRect(x, y, width, height);
      },
      drawArrow: function(ctx, startX, startY) {
        var lineWidth;
        lineWidth = ctx.lineWidth;
        ctx.lineWidth = app.constants.arrowLineWidth;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(startX + 150, startY);
        ctx.lineTo(startX + 120, startY + 30);
        ctx.moveTo(startX + 150, startY);
        ctx.lineTo(startX + 120, startY - 30);
        ctx.stroke();
        return ctx.lineWidth = lineWidth;
      },
      renderSkipText: function() {
        var canvas, ctx;
        canvas = ($(this.el)[0]);
        ctx = canvas.getContext("2d");
        ctx.fillStyle = app.constants.textColor;
        ctx.font = app.constants.textFont;
        return ctx.fillText("Press [Enter] to Skip Cinema", 10, 20);
      },
      renderLedge: function(npcColor) {
        var canvas, ctx;
        canvas = ($(this.el)[0]);
        ctx = canvas.getContext("2d");
        ctx.fillStyle = app.constants.ledgeColor;
        ctx.fillRect(app.constants.canvasX - 300, 300, 300, 50);
        ctx.fillStyle = npcColor;
        return ctx.fillRect(app.constants.canvasX - 280, 248, app.constants.playerSizeX, app.constants.playerSizeY);
      },
      renderGameOver: function() {
        var canvas, ctx;
        canvas = ($(this.el)[0]);
        ctx = canvas.getContext("2d");
        ctx.fillStyle = app.constants.textColor;
        ctx.font = app.constants.textFont;
        ctx.fillText("You win!", app.constants.canvasX / 2, app.constants.canvasY / 2);
        ctx.font === app.constants.smallTextFont;
        return ctx.fillText("Sort of...", app.constants.canvasX / 2, app.constants.canvasY / 2 + 50);
      }
    });
    return app.Rounds = Backbone.Collection.extend({
      model: app.RoundModel,
      update: function() {
        if (this.currentRound == null) {
          this.nextRound();
        }
        return this.currentRound.update();
      },
      initialize: function() {
        var x, _i, _ref, _results;
        this.add([
          {
            numberOfMonstersPerWave: [1, 2, 3],
            introText: [["Princess", "Save me Blocky! You're my only hope!  "], ["Blocky", "/wink, hey babe.  "], ["Princess", "Omg gross. Just save me alright.  "]],
            introNPC: "Princess",
            groundHeight: [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            bgImageSrc: "img/background1.png"
          }, {
            numberOfMonstersPerWave: [3, 4, 6],
            introText: [["Thor", "Don't get cocky son.   "], ["Blocky", "Who the hell are you?   "], ["Thor", "I am Thor. Creator of death...   "], ["Blocky", "/cough loser  "], ["Thor", "YOU WILL PAY FOR YOUR INSOLENCE!   "]],
            introNPC: "Thor",
            groundHeight: [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            bgImageSrc: "img/background2.png"
          }, {
            numberOfMonstersPerWave: [5, 7, 9, 11],
            introText: [["Blocky", "DAMN GIRL, THOSE PANTS ARE TIGHT.   "], ["Princess", "fml... Watch out! More minions!   "]],
            introNPC: "Princess",
            groundHeight: [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0],
            bgImageSrc: "img/background3.png"
          }, {
            bgImageSrc: "img/background4.png",
            numberOfMonstersPerWave: [10, 10, 15],
            introText: [["Thor", "My my, you're doing better than I thought   "], ["Blocky", "LIKE A BOSS  "], ["Thor", "Such cockiness, it's going to get you killed.   "], ["Blocky", "Thor, have you heard the lore, of your mother, the whore?   "], ["Thor", "ENOUGH. This madness has gone on long enough!   "]],
            introNPC: "Thor",
            groundHeight: [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0],
            outroNPC: "Princess",
            outroText: [["Princess", "Maybe I was a little mean to you...   "], ["Blocky", "Babe, it coo  "], ["Princess", "Rescue me, and I have a little surprise for you :)   "], ["Blocky", "aww yeah  "], ["Princess", "Careful. He's in the next room   "]]
          }, {
            bgImageSrc: "img/background5.png",
            monsterColor: app.constants.npcColor['Thor'],
            numberOfMonstersPerWave: [1],
            introNPC: "Thor",
            introText: [["Thor", "Well well well, look what the cat dragged in.  "], ["Blocky", "The finest piece of ass?   "], ["Thor", "Are you implying that you're... nvm, anyways...   "], ["Blocky", ""], ["Thor", "Prepare to die! Mwahahaha"]],
            outroNPC: "Thor",
            outroText: [["Thor", "Nooooo, rainbow bullets, my only weakness.   "], ["BLocky", ""], ["Thor", "How did you know?   "]]
          }, {
            numberOfMonstersPerWave: [],
            bgImageSrc: "img/background6.png",
            introNPC: "Princess",
            introText: [["Princess", "You saved me?! You did it!"], ["Blocky", "So about that \"Special Surprise\"... /wink   "], ["Princess", "LULLERBLADES, let's get real...    "], ["Blocky", ":(   "]]
          }, {
            isGameOver: true
          }
        ]);
        this.roundNumber = 0;
        if (app.constants.startRound > 0) {
          _results = [];
          for (x = _i = 0, _ref = app.constants.startRound; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
            this.shift();
            _results.push(this.roundNumber += 1);
          }
          return _results;
        }
      },
      nextRound: function() {
        if (!this.isEmpty()) {
          this.roundNumber += 1;
          this.currentRound = this.shift();
          this.loadImage();
          this.listenTo(this.currentRound, 'roundComplete', this.nextRound);
          return this.currentView = new app.RoundView({
            model: this.currentRound
          });
        }
      },
      loadImage: function() {
        var image;
        if (this.currentRound.get('bgImageSrc')) {
          image = new Image();
          image.src = this.currentRound.get('bgImageSrc');
          return this.currentRound.set('bgImage', image);
        }
      },
      getRoundNumber: function() {
        return this.roundNumber;
      },
      getWaveNumber: function() {
        return this.currentRound.get('currentWaveNumber');
      },
      getBackground: function() {
        return this.currentRound.get('bgImage');
      },
      render: function() {
        return this.currentView.render();
      },
      height: function(x) {
        if (this.currentRound == null) {
          return 0;
        }
        return this.currentRound.height(x);
      }
    });
  });

}).call(this);
